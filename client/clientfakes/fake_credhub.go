// Code generated by counterfeiter. DO NOT EDIT.
package clientfakes

import (
	"sync"

	"github.com/jghiloni/credhub-sdk/client"
)

type FakeCredhub struct {
	FindByPathStub        func(path string) (client.FindByPathResults, error)
	findByPathMutex       sync.RWMutex
	findByPathArgsForCall []struct {
		path string
	}
	findByPathReturns struct {
		result1 client.FindByPathResults
		result2 error
	}
	findByPathReturnsOnCall map[int]struct {
		result1 client.FindByPathResults
		result2 error
	}
	GetByNameStub        func(name string) (client.GetByNameResults, error)
	getByNameMutex       sync.RWMutex
	getByNameArgsForCall []struct {
		name string
	}
	getByNameReturns struct {
		result1 client.GetByNameResults
		result2 error
	}
	getByNameReturnsOnCall map[int]struct {
		result1 client.GetByNameResults
		result2 error
	}
	GetLatestByNameStub        func(name string) (client.Credential, error)
	getLatestByNameMutex       sync.RWMutex
	getLatestByNameArgsForCall []struct {
		name string
	}
	getLatestByNameReturns struct {
		result1 client.Credential
		result2 error
	}
	getLatestByNameReturnsOnCall map[int]struct {
		result1 client.Credential
		result2 error
	}
	SetStub        func(credential client.Credential) (client.Credential, error)
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		credential client.Credential
	}
	setReturns struct {
		result1 client.Credential
		result2 error
	}
	setReturnsOnCall map[int]struct {
		result1 client.Credential
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCredhub) FindByPath(path string) (client.FindByPathResults, error) {
	fake.findByPathMutex.Lock()
	ret, specificReturn := fake.findByPathReturnsOnCall[len(fake.findByPathArgsForCall)]
	fake.findByPathArgsForCall = append(fake.findByPathArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("FindByPath", []interface{}{path})
	fake.findByPathMutex.Unlock()
	if fake.FindByPathStub != nil {
		return fake.FindByPathStub(path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findByPathReturns.result1, fake.findByPathReturns.result2
}

func (fake *FakeCredhub) FindByPathCallCount() int {
	fake.findByPathMutex.RLock()
	defer fake.findByPathMutex.RUnlock()
	return len(fake.findByPathArgsForCall)
}

func (fake *FakeCredhub) FindByPathArgsForCall(i int) string {
	fake.findByPathMutex.RLock()
	defer fake.findByPathMutex.RUnlock()
	return fake.findByPathArgsForCall[i].path
}

func (fake *FakeCredhub) FindByPathReturns(result1 client.FindByPathResults, result2 error) {
	fake.FindByPathStub = nil
	fake.findByPathReturns = struct {
		result1 client.FindByPathResults
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) FindByPathReturnsOnCall(i int, result1 client.FindByPathResults, result2 error) {
	fake.FindByPathStub = nil
	if fake.findByPathReturnsOnCall == nil {
		fake.findByPathReturnsOnCall = make(map[int]struct {
			result1 client.FindByPathResults
			result2 error
		})
	}
	fake.findByPathReturnsOnCall[i] = struct {
		result1 client.FindByPathResults
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) GetByName(name string) (client.GetByNameResults, error) {
	fake.getByNameMutex.Lock()
	ret, specificReturn := fake.getByNameReturnsOnCall[len(fake.getByNameArgsForCall)]
	fake.getByNameArgsForCall = append(fake.getByNameArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("GetByName", []interface{}{name})
	fake.getByNameMutex.Unlock()
	if fake.GetByNameStub != nil {
		return fake.GetByNameStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getByNameReturns.result1, fake.getByNameReturns.result2
}

func (fake *FakeCredhub) GetByNameCallCount() int {
	fake.getByNameMutex.RLock()
	defer fake.getByNameMutex.RUnlock()
	return len(fake.getByNameArgsForCall)
}

func (fake *FakeCredhub) GetByNameArgsForCall(i int) string {
	fake.getByNameMutex.RLock()
	defer fake.getByNameMutex.RUnlock()
	return fake.getByNameArgsForCall[i].name
}

func (fake *FakeCredhub) GetByNameReturns(result1 client.GetByNameResults, result2 error) {
	fake.GetByNameStub = nil
	fake.getByNameReturns = struct {
		result1 client.GetByNameResults
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) GetByNameReturnsOnCall(i int, result1 client.GetByNameResults, result2 error) {
	fake.GetByNameStub = nil
	if fake.getByNameReturnsOnCall == nil {
		fake.getByNameReturnsOnCall = make(map[int]struct {
			result1 client.GetByNameResults
			result2 error
		})
	}
	fake.getByNameReturnsOnCall[i] = struct {
		result1 client.GetByNameResults
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) GetLatestByName(name string) (client.Credential, error) {
	fake.getLatestByNameMutex.Lock()
	ret, specificReturn := fake.getLatestByNameReturnsOnCall[len(fake.getLatestByNameArgsForCall)]
	fake.getLatestByNameArgsForCall = append(fake.getLatestByNameArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("GetLatestByName", []interface{}{name})
	fake.getLatestByNameMutex.Unlock()
	if fake.GetLatestByNameStub != nil {
		return fake.GetLatestByNameStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getLatestByNameReturns.result1, fake.getLatestByNameReturns.result2
}

func (fake *FakeCredhub) GetLatestByNameCallCount() int {
	fake.getLatestByNameMutex.RLock()
	defer fake.getLatestByNameMutex.RUnlock()
	return len(fake.getLatestByNameArgsForCall)
}

func (fake *FakeCredhub) GetLatestByNameArgsForCall(i int) string {
	fake.getLatestByNameMutex.RLock()
	defer fake.getLatestByNameMutex.RUnlock()
	return fake.getLatestByNameArgsForCall[i].name
}

func (fake *FakeCredhub) GetLatestByNameReturns(result1 client.Credential, result2 error) {
	fake.GetLatestByNameStub = nil
	fake.getLatestByNameReturns = struct {
		result1 client.Credential
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) GetLatestByNameReturnsOnCall(i int, result1 client.Credential, result2 error) {
	fake.GetLatestByNameStub = nil
	if fake.getLatestByNameReturnsOnCall == nil {
		fake.getLatestByNameReturnsOnCall = make(map[int]struct {
			result1 client.Credential
			result2 error
		})
	}
	fake.getLatestByNameReturnsOnCall[i] = struct {
		result1 client.Credential
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) Set(credential client.Credential) (client.Credential, error) {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		credential client.Credential
	}{credential})
	fake.recordInvocation("Set", []interface{}{credential})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(credential)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setReturns.result1, fake.setReturns.result2
}

func (fake *FakeCredhub) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeCredhub) SetArgsForCall(i int) client.Credential {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return fake.setArgsForCall[i].credential
}

func (fake *FakeCredhub) SetReturns(result1 client.Credential, result2 error) {
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 client.Credential
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) SetReturnsOnCall(i int, result1 client.Credential, result2 error) {
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 client.Credential
			result2 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 client.Credential
		result2 error
	}{result1, result2}
}

func (fake *FakeCredhub) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findByPathMutex.RLock()
	defer fake.findByPathMutex.RUnlock()
	fake.getByNameMutex.RLock()
	defer fake.getByNameMutex.RUnlock()
	fake.getLatestByNameMutex.RLock()
	defer fake.getLatestByNameMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCredhub) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Credhub = new(FakeCredhub)
